{"version":3,"sources":["../../../lib/core/matchers/query-string-matcher.js"],"names":["TYPE_SPECIFIC_REGEX","getMatchingResultByQueryStrings","masterQS","slaveQS","isMasterExist","JSON","stringify","isSlaveExist","result","countOfMatches","countOfMatchesUnspecific","forEach","name","values","type","isContained","indexOf","isSpecific","value","regex","RegExp","test","masterQSLength","Object","keys","length","slaveQSLength","SUBSET","getMatchesByQueryString","req","definitions","matches","record","query","queryStringParameters","isNo","push"],"mappings":";;;;;;;AAAA;;;;AACA;;AACA;;;;;;AAOA,MAAMA,sBAAsB,gBAA5B;;AAEA;;;;;;;;;AASO,MAAMC,4EAAkC,CAACC,QAAD,EAAWC,OAAX,KAAuB;AACpE,MAAIC,gBAAgB,CAAC,CAACF,QAAF,IAAcG,KAAKC,SAAL,CAAeJ,QAAf,MAA6B,IAA/D;AACA,MAAIK,eAAe,CAAC,CAACJ,OAArB;AACA;AACA;AACA;AACA;AACA,MAAI,CAACC,aAAD,IAAkB,CAACG,YAAvB,EAAqC;AACrC,MAAI,CAACH,aAAD,IAAkBG,YAAtB,EAAoC;AACpC,MAAIH,iBAAiB,CAACG,YAAtB,EAAoC;AACpC,MAAIC,SAAS,IAAb;AACA,MAAIC,iBAAiB,CAArB;AACA,MAAIC,2BAA2B,CAA/B;AACAP,UAAQQ,OAAR,CAAgB,CAAC,EAAEC,IAAF,EAAQC,MAAR,EAAgBC,IAAhB,EAAD,KAA4B;AAC1C,QAAI,CAACZ,SAASU,IAAT,CAAL,EAAqB;AACnBJ;AACD,KAFD,MAEO;AACL,UAAIO,cAAcF,OAAOG,OAAP,CAAed,SAASU,IAAT,CAAf,MAAmC,CAAC,CAAtD;;AAEA,UAAIK,aAAaJ,OAAOG,OAAP,yBAA4B,CAAC,CAA9C;AACA,UAAIF,SAASd,mBAAb,EAAkC;AAChCiB,qBAAa,IAAb;AACA,YAAI,CAACF,WAAL,EAAkB;AAChBF,iBAAOF,OAAP,CAAeO,SAAS;AACtB,gBAAIC,QAAQ,IAAIC,MAAJ,CAAWF,KAAX,CAAZ;;AAEA;AACA;AACA;AACA;AACA,gBAAIC,MAAME,IAAN,CAAWnB,SAASU,IAAT,CAAX,CAAJ,EAAgC;AAC9BK,2BAAa,KAAb;AACD;AACF,WAVD;AAWD;AACF;;AAED,UAAIA,cAAc,CAACF,WAAnB,EAAgC;AAC9BP;AACD,OAFD,MAEO;AACL,YAAI,CAACS,UAAL,EAAiBP;AACjBD;AACD;AACF;AACF,GA/BD;;AAiCA,MAAID,WAAW,IAAf,EAAqB,OAAOA,MAAP;;AAErB,MAAIc,iBAAiBC,OAAOC,IAAP,CAAYtB,QAAZ,EAAsBuB,MAA3C;AACA,MAAIC,gBAAgBvB,QAAQsB,MAA5B;;AAEA,MAAIC,kBAAkBjB,cAAlB,IAAoCA,mBAAmBa,cAA3D,EACE;AACF,SAAO,6BACL,2BAAWK,MADN,EAELlB,cAFK,EAGLC,wBAHK,CAAP;AAKD,CA1DM;;AA4DA,MAAMkB,4DAA0B,CAACC,GAAD,EAAMC,WAAN,KAAsB;AAC3D,MAAIC,UAAU,EAAd;AACAD,cAAYnB,OAAZ,CAAoBqB,UAAU;AAC5B;AACA;AACA,QAAIxB,SAASP,gCACX4B,IAAII,KADO,EAEXD,OAAOE,qBAFI,CAAb;AAIA;AACA;AACA,QAAI,CAAC1B,OAAO2B,IAAP,EAAL,EAAoB;AAClBJ,cAAQK,IAAR,CAAa,wBAAcJ,MAAd,EAAsBxB,MAAtB,CAAb;AACD;AACF,GAZD;AAaA,SAAOuB,OAAP;AACD,CAhBM","file":"query-string-matcher.js","sourcesContent":["import MatchItem from './MatchItem';\nimport { REG_ALL } from '../../constants';\nimport MatchingResult, {\n  MATCH_DEFAULT,\n  MATCH_NO,\n  MATCH_STRICT,\n  MATCH_TYPE\n} from './MatchingResult';\n\nconst TYPE_SPECIFIC_REGEX = 'SPECIFIC_REGEX';\n\n/**\n *                  exist     dont      exist     dont\n *  req/master        0         1         0         1\n *  bundle/slave      0         0         1         1\n *  result =          strict    default   no        subset/no\n *\n *  @param {Object} masterQS          request\n *  @param {Array.<Object>} slaveQS   bundle\n */\nexport const getMatchingResultByQueryStrings = (masterQS, slaveQS) => {\n  let isMasterExist = !!masterQS && JSON.stringify(masterQS) !== '{}';\n  let isSlaveExist = !!slaveQS;\n  // console.log('+++++++++++'.green);\n  // console.log(masterQS);\n  // console.log(slaveQS);\n  // console.log('+++++++++++'.blue);\n  if (!isMasterExist && !isSlaveExist) return MATCH_STRICT;\n  if (!isMasterExist && isSlaveExist) return MATCH_NO;\n  if (isMasterExist && !isSlaveExist) return MATCH_DEFAULT;\n  let result = null;\n  let countOfMatches = 0;\n  let countOfMatchesUnspecific = 0;\n  slaveQS.forEach(({ name, values, type }) => {\n    if (!masterQS[name]) {\n      result = MATCH_NO;\n    } else {\n      let isContained = values.indexOf(masterQS[name]) !== -1;\n\n      let isSpecific = values.indexOf(REG_ALL) === -1;\n      if (type === TYPE_SPECIFIC_REGEX) {\n        isSpecific = true;\n        if (!isContained) {\n          values.forEach(value => {\n            let regex = new RegExp(value);\n\n            // console.log(name);\n            // console.log(regex);\n            // console.log(masterQS[name]);\n            // console.log('regex.test(masterQS[name]) ' +regex.test(masterQS[name]));\n            if (regex.test(masterQS[name])) {\n              isSpecific = false;\n            }\n          });\n        }\n      }\n\n      if (isSpecific && !isContained) {\n        result = MATCH_NO;\n      } else {\n        if (!isSpecific) countOfMatchesUnspecific++;\n        countOfMatches++;\n      }\n    }\n  });\n\n  if (result !== null) return result;\n\n  let masterQSLength = Object.keys(masterQS).length;\n  let slaveQSLength = slaveQS.length;\n\n  if (slaveQSLength === countOfMatches && countOfMatches === masterQSLength)\n    return MATCH_STRICT;\n  return new MatchingResult(\n    MATCH_TYPE.SUBSET,\n    countOfMatches,\n    countOfMatchesUnspecific\n  );\n};\n\nexport const getMatchesByQueryString = (req, definitions) => {\n  let matches = [];\n  definitions.forEach(record => {\n    // console.log(req.query);\n    // console.log(record.queryStringParameters);\n    let result = getMatchingResultByQueryStrings(\n      req.query,\n      record.queryStringParameters\n    );\n    // console.log('result');\n    // console.log(result);\n    if (!result.isNo()) {\n      matches.push(new MatchItem(record, result));\n    }\n  });\n  return matches;\n};\n"]}