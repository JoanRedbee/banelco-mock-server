'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getMatchesByQueryString = exports.getMatchingResultByQueryStrings = undefined;

var _MatchItem = require('./MatchItem');

var _MatchItem2 = _interopRequireDefault(_MatchItem);

var _constants = require('../../constants');

var _MatchingResult = require('./MatchingResult');

var _MatchingResult2 = _interopRequireDefault(_MatchingResult);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const TYPE_SPECIFIC_REGEX = 'SPECIFIC_REGEX';

/**
 *                  exist     dont      exist     dont
 *  req/master        0         1         0         1
 *  bundle/slave      0         0         1         1
 *  result =          strict    default   no        subset/no
 *
 *  @param {Object} masterQS          request
 *  @param {Array.<Object>} slaveQS   bundle
 */
const getMatchingResultByQueryStrings = exports.getMatchingResultByQueryStrings = (masterQS, slaveQS) => {
  let isMasterExist = !!masterQS && JSON.stringify(masterQS) !== '{}';
  let isSlaveExist = !!slaveQS;
  // console.log('+++++++++++'.green);
  // console.log(masterQS);
  // console.log(slaveQS);
  // console.log('+++++++++++'.blue);
  if (!isMasterExist && !isSlaveExist) return _MatchingResult.MATCH_STRICT;
  if (!isMasterExist && isSlaveExist) return _MatchingResult.MATCH_NO;
  if (isMasterExist && !isSlaveExist) return _MatchingResult.MATCH_DEFAULT;
  let result = null;
  let countOfMatches = 0;
  let countOfMatchesUnspecific = 0;
  slaveQS.forEach(({ name, values, type }) => {
    if (!masterQS[name]) {
      result = _MatchingResult.MATCH_NO;
    } else {
      let isContained = values.indexOf(masterQS[name]) !== -1;

      let isSpecific = values.indexOf(_constants.REG_ALL) === -1;
      if (type === TYPE_SPECIFIC_REGEX) {
        isSpecific = true;
        if (!isContained) {
          values.forEach(value => {
            let regex = new RegExp(value);

            // console.log(name);
            // console.log(regex);
            // console.log(masterQS[name]);
            // console.log('regex.test(masterQS[name]) ' +regex.test(masterQS[name]));
            if (regex.test(masterQS[name])) {
              isSpecific = false;
            }
          });
        }
      }

      if (isSpecific && !isContained) {
        result = _MatchingResult.MATCH_NO;
      } else {
        if (!isSpecific) countOfMatchesUnspecific++;
        countOfMatches++;
      }
    }
  });

  if (result !== null) return result;

  let masterQSLength = Object.keys(masterQS).length;
  let slaveQSLength = slaveQS.length;

  if (slaveQSLength === countOfMatches && countOfMatches === masterQSLength) return _MatchingResult.MATCH_STRICT;
  return new _MatchingResult2.default(_MatchingResult.MATCH_TYPE.SUBSET, countOfMatches, countOfMatchesUnspecific);
};

const getMatchesByQueryString = exports.getMatchesByQueryString = (req, definitions) => {
  let matches = [];
  definitions.forEach(record => {
    // console.log(req.query);
    // console.log(record.queryStringParameters);
    let result = getMatchingResultByQueryStrings(req.query, record.queryStringParameters);
    // console.log('result');
    // console.log(result);
    if (!result.isNo()) {
      matches.push(new _MatchItem2.default(record, result));
    }
  });
  return matches;
};
//# sourceMappingURL=query-string-matcher.js.map